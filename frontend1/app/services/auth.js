import CryptoJS from 'crypto-js';
import { API_CONFIG, AUTH_ENDPOINTS, buildApiUrl, apiRequest } from '../../lib/api-config';

class AuthService {
  /**
   * Generate challenge code based on current UTC timestamp
   */
  generateChallengeCode() {
    const now = new Date();
    const year = now.getUTCFullYear();
    const month = String(now.getUTCMonth() + 1).padStart(2, '0');
    const day = String(now.getUTCDate()).padStart(2, '0');
    const hours = String(now.getUTCHours()).padStart(2, '0');
    const minutes = String(now.getUTCMinutes()).padStart(2, '0');
    const seconds = String(now.getUTCSeconds()).padStart(2, '0');
    
    return `${year}${month}${day}${hours}${minutes}${seconds}`;
  }

  /**
   * Hash password with SHA256
   */
  hashPasswordWithSHA256(input) {
    const hash = CryptoJS.SHA256(input);
    return CryptoJS.enc.Base64.stringify(hash);
  }

  /**
   * Encrypt password with challenge code
   */
  encryptPasswordWithChallenge(password, challenge) {
    const passwordWithChallenge = password + challenge;
    return this.hashPasswordWithSHA256(passwordWithChallenge);
  }

  /**
   * Generate device ID for current browser/device
   */
  generateDeviceId() {
    const existingDeviceId = localStorage.getItem('deviceId');
    if (existingDeviceId) {
      return existingDeviceId;
    }

    const userAgent = navigator.userAgent;
    const screenResolution = `${screen.width}x${screen.height}`;
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const language = navigator.language;
    
    const deviceString = `${userAgent}-${screenResolution}-${timezone}-${language}-${Date.now()}`;
    const deviceId = this.hashPasswordWithSHA256(deviceString).substring(0, 32);
    
    localStorage.setItem('deviceId', deviceId);
    return deviceId;
  }

  /**
   * Login user with credentials
   */
  async login(userId, password) {
    try {
      const challengeCode = this.generateChallengeCode();
      const encryptedPassword = this.encryptPasswordWithChallenge(password, challengeCode);
      const deviceId = this.generateDeviceId();

      const requestBody = {
        userID: userId,
        password: encryptedPassword,
        challengeCode: challengeCode,
        deviceId: deviceId
      };

      const response = await fetch(buildApiUrl(AUTH_ENDPOINTS.getToken), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(errorData || 'Login failed');
      }

      const data = await response.json();
      console.log('🔐 LOGIN API RESPONSE:', JSON.stringify(data, null, 2));
      
      // Debug: Show all fields in the response
      console.log('📋 All fields in API response:');
      Object.keys(data).forEach(key => {
        const value = data[key];
        const valueType = typeof value;
        const valuePreview = valueType === 'string' ? value.slice(0, 50) + (value.length > 50 ? '...' : '') : valueType;
        console.log(`  - ${key}: ${valuePreview}`);
      });
      
      // IMPORTANT: The server should generate a UNIQUE token for each user login
      // This token should be different every time someone logs in
      // It contains user info, permissions, and expiration time
      const token = data.token || data.Token || data.access_token || data.AccessToken || 
                   data.authToken || data.AuthToken || data.jwt || data.JWT ||
                   data.accessToken || data.bearerToken || data.sessionToken ||
                   (data.Data && data.Data.Token) || (data.Data && data.Data.token);
      
      if (token) {
        console.log('✅ Token generated by API and received:', token.slice(0, 20) + '...');
        console.log('✅ Storing token in localStorage');
        localStorage.setItem('authToken', token);
        localStorage.setItem('userId', userId);
        
        // Store any additional user data
        const userData = data.user || data.User || data.userData || data.userInfo || { name: userId };
        localStorage.setItem('userData', JSON.stringify(userData));
        
        console.log('✅ Token storage complete');
      } else {
        console.error('❌ No token generated/returned by API');
        console.error('Available fields in response:', Object.keys(data));
        console.error('Full response:', data);
        
        // Try to find token in nested objects
        let foundToken = null;
        
        // Check all properties recursively
        const findTokenRecursively = (obj, path = '') => {
          if (typeof obj === 'object' && obj !== null) {
            for (const [key, value] of Object.entries(obj)) {
              const currentPath = path ? `${path}.${key}` : key;
              
              // Check if this field might be a token (JWT tokens start with 'eyJ')
              if (typeof value === 'string' && (
                key.toLowerCase().includes('token') ||
                key.toLowerCase().includes('jwt') ||
                key.toLowerCase().includes('bearer') ||
                value.startsWith('eyJ') // JWT tokens start with 'eyJ'
              )) {
                foundToken = value;
                return;
              }
              
              // Recurse into nested objects
              if (typeof value === 'object') {
                findTokenRecursively(value, currentPath);
              }
            }
          }
        };
        
        findTokenRecursively(data);
        
        if (foundToken) {
          localStorage.setItem('authToken', foundToken);
          localStorage.setItem('userId', userId);
          const userData = data.user || data.User || data.userData || data.userInfo || { name: userId };
          localStorage.setItem('userData', JSON.stringify(userData));
          
          // Update the data object to include the found token
          data.token = foundToken;
        } else {
          // Don't fail login if no token, maybe API uses different authentication
          localStorage.setItem('userId', userId);
          localStorage.setItem('userData', JSON.stringify({ name: userId }));
        }
      }

      return {
        success: true,
        data: {
          ...data,
          token: token // Ensure token is available in data object
        }
      };
    } catch (error) {
      console.error('Login error:', error);
      return {
        success: false,
        error: error.message || 'An error occurred during login'
      };
    }
  }

  /**
   * Logout user
   */
  logout() {
    localStorage.removeItem('authToken');
    localStorage.removeItem('userId');
    localStorage.removeItem('userData');
    // Keep deviceId for future logins
  }

  /**
   * Check if user is authenticated
   */
  isAuthenticated() {
    return !!localStorage.getItem('authToken');
  }

  /**
   * Get stored auth token
   */
  getAuthToken() {
    return localStorage.getItem('authToken');
  }

  /**
   * Get stored user data
   */
  getUserData() {
    const userData = localStorage.getItem('userData');
    return userData ? JSON.parse(userData) : null;
  }

  /**
   * Set authorization header for API requests
   */
  getAuthHeaders() {
    const token = this.getAuthToken();
    return token ? {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    } : {
      'Content-Type': 'application/json'
    };
  }
}

export default new AuthService();