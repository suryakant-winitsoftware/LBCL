import { apiService } from "./api";

// Journey Plan interfaces (READ-ONLY)
export interface JourneyPlan {
  beatHistoryUID: string;
  visitDate: string;
  salesmanName: string;
  salesmanLoginId: string;
  routeUID: string;
  routeName: string;
  vehicleName?: string;
  empUID: string;
  scheduleCall: number;
  actualStoreVisits: number;
  skippedStore: number;
  pendingVisits: number;
  status?: string;
}

export interface StoreVisit {
  storeUID: string;
  storeName: string;
  storeCode: string;
  plannedLoginTime: string;
  plannedLogoutTime: string;
  actualLoginTime?: string;
  actualLogoutTime?: string;
  status: "Visited" | "Pending" | "Skipped";
  isProductive: boolean;
  orderValue: number;
  latitude?: string;
  longitude?: string;
  serialNo: number;
}

export interface UserJourney {
  uid: string;
  jobPositionUID: string;
  empUID: string;
  empName: string;
  routeName: string;
  journeyStartTime?: string;
  journeyEndTime?: string;
  totalStores: number;
  visitedStores: number;
  skippedStores: number;
  productiveCalls: number;
  totalOrderValue: number;
  startOdometerReading?: number;
  endOdometerReading?: number;
  totalDistance?: number;
  attendanceStatus?: string;
  attendanceLatitude?: string;
  attendanceLongitude?: string;
  beatHistoryUID: string;
  hasAuditCompleted: boolean;
  eotStatus?: string;
}

/**
 * Fixed Journey Plan Service
 * IMPORTANT: Journey plans are AUTO-GENERATED by the system
 * This service only supports READ, VIEW, and REASSIGN operations
 * NO CREATE OR EDIT functionality exists (intentionally removed)
 */
export const journeyPlanServiceFixed = {
  /**
   * Get journey plans for a specific date
   * Plans are auto-generated nightly at 11 PM
   */
  async getTodayJourneyPlanDetails(params: {
    visitDate: Date | string;
    type: "Assigned" | "UnAssigned";
    orgUID: string;
    jobPositionUID?: string;
    pageNumber?: number;
    pageSize?: number;
  }) {
    try {
      const response = await apiService.post(
        "/UserJourney/SelectTodayJourneyPlanDetails",
        {
          visitDate:
            typeof params.visitDate === "string"
              ? params.visitDate
              : params.visitDate.toISOString(),
          type: params.type,
          orgUID: params.orgUID,
          jobPositionUID: params.jobPositionUID || "",
          pageNumber: params.pageNumber || 1,
          pageSize: params.pageSize || 50,
          isCountRequired: true,
          sortCriterias: [],
          filterCriterias: []
        }
      );
      return response?.data || { pagedData: [], totalCount: 0 };
    } catch (error) {
      console.error("Error fetching journey plans:", error);
      throw error;
    }
  },

  /**
   * Get all user journeys (execution history)
   */
  async getAllUserJourneys(params: {
    empUID?: string;
    pageNumber?: number;
    pageSize?: number;
    sortCriterias?: Array<{
      columnName: string;
      sortDirection: "ASC" | "DESC";
    }>;
    filterCriterias?: Array<{
      columnName: string;
      filterValue: string;
      filterType: string;
    }>;
  }) {
    try {
      const response = await apiService.post(
        "/UserJourney/SelectAlUserJourneyDetails",
        {
          pageNumber: params.pageNumber || 1,
          pageSize: params.pageSize || 50,
          isCountRequired: true,
          sortCriterias: params.sortCriterias || [
            {
              columnName: "JourneyStartTime",
              sortDirection: "DESC"
            }
          ],
          filterCriterias: params.filterCriterias || []
        }
      );
      return response?.data || { pagedData: [], totalCount: 0 };
    } catch (error) {
      console.error("Error fetching user journeys:", error);
      throw error;
    }
  },

  /**
   * Get journey details by ID
   */
  async getJourneyDetailsByUID(uid: string): Promise<UserJourney | null> {
    try {
      const response = await apiService.get(
        `/UserJourney/GetUserJourneyDetailsByUID?UID=${uid}`
      );
      return response?.data || null;
    } catch (error) {
      console.error("Error fetching journey details:", error);
      throw error;
    }
  },

  /**
   * Get store visit details for a journey plan
   */
  async getStoreVisitDetails(beatHistoryUID: string): Promise<StoreVisit[]> {
    try {
      const response = await apiService.post(
        "/UserJourney/SelecteatHistoryInnerGridDetails",
        {
          beatHistoryUID
        }
      );
      return response?.data || [];
    } catch (error) {
      console.error("Error fetching store visit details:", error);
      return [];
    }
  },

  /**
   * Reassign journey plan to different salesman
   * Only works for unstarted journey plans
   */
  async reassignJourneyPlan(params: {
    beatHistoryUID: string;
    newEmpUID: string;
    newJobPositionUID: string;
    reassignedBy: string;
    reason?: string;
  }) {
    try {
      // This endpoint might need backend implementation
      // The backend should check:
      // 1. Journey hasn't started (no check-ins)
      // 2. New employee is available
      // 3. Update beat_history and user_journey tables
      const response = await apiService.post(
        "/UserJourney/ReassignJourneyPlan",
        {
          beatHistoryUID: params.beatHistoryUID,
          newEmpUID: params.newEmpUID,
          newJobPositionUID: params.newJobPositionUID,
          reassignedBy: params.reassignedBy,
          reason: params.reason || "Manual reassignment",
          reassignedTime: new Date().toISOString()
        }
      );
      return response;
    } catch (error) {
      console.error("Error reassigning journey plan:", error);
      // If API doesn't exist, provide fallback message
      if (error?.response?.status === 404) {
        throw new Error(
          "Reassign functionality not yet implemented in backend"
        );
      }
      throw error;
    }
  },

  /**
   * Cancel journey plan
   * Only works for unstarted journey plans
   */
  async cancelJourneyPlan(params: {
    beatHistoryUID: string;
    cancelledBy: string;
    reason: string;
  }) {
    try {
      // This endpoint might need backend implementation
      // The backend should check:
      // 1. Journey hasn't started
      // 2. Update beat_history status to 'Cancelled'
      const response = await apiService.post("/UserJourney/CancelJourneyPlan", {
        beatHistoryUID: params.beatHistoryUID,
        cancelledBy: params.cancelledBy,
        reason: params.reason,
        cancelledTime: new Date().toISOString()
      });
      return response;
    } catch (error) {
      console.error("Error cancelling journey plan:", error);
      // If API doesn't exist, provide fallback message
      if (error?.response?.status === 404) {
        throw new Error("Cancel functionality not yet implemented in backend");
      }
      throw error;
    }
  },

  /**
   * Get journey plan statistics for dashboard
   */
  async getJourneyPlanStats(params: {
    orgUID: string;
    startDate: string;
    endDate: string;
  }) {
    try {
      const response = await apiService.post(
        "/UserJourney/GetJourneyPlanStatistics",
        {
          orgUID: params.orgUID,
          startDate: params.startDate,
          endDate: params.endDate
        }
      );
      return (
        response?.data || {
          totalPlans: 0,
          completedPlans: 0,
          inProgressPlans: 0,
          pendingPlans: 0,
          cancelledPlans: 0,
          totalStores: 0,
          visitedStores: 0,
          productiveStores: 0,
          skippedStores: 0,
          avgCompletionRate: 0,
          totalOrderValue: 0
        }
      );
    } catch (error) {
      console.error("Error fetching journey plan statistics:", error);
      // Return default stats if API doesn't exist
      return {
        totalPlans: 0,
        completedPlans: 0,
        inProgressPlans: 0,
        pendingPlans: 0,
        cancelledPlans: 0,
        totalStores: 0,
        visitedStores: 0,
        productiveStores: 0,
        skippedStores: 0,
        avgCompletionRate: 0,
        totalOrderValue: 0
      };
    }
  },

  /**
   * Get employees available for reassignment
   */
  async getAvailableEmployees(params: {
    orgUID: string;
    roleUID: string;
    date: string;
  }) {
    try {
      // Get employees who don't have journey plans for this date
      const response = await apiService.post(
        "/Employee/GetAvailableEmployeesForDate",
        {
          orgUID: params.orgUID,
          roleUID: params.roleUID,
          date: params.date
        }
      );
      return response?.data || [];
    } catch (error) {
      console.error("Error fetching available employees:", error);
      // Fallback: get all employees if specific endpoint doesn't exist
      try {
        const allEmployees = await apiService.get(
          `/Employee/GetEmployeesByOrg?orgUID=${params.orgUID}`
        );
        return allEmployees?.data || [];
      } catch (fallbackError) {
        return [];
      }
    }
  },

  /**
   * Get journey plan history for a route
   */
  async getRoutJourneyHistory(params: {
    routeUID: string;
    startDate: string;
    endDate: string;
    pageNumber?: number;
    pageSize?: number;
  }) {
    try {
      const response = await apiService.post(
        "/UserJourney/GetRouteJourneyHistory",
        {
          routeUID: params.routeUID,
          startDate: params.startDate,
          endDate: params.endDate,
          pageNumber: params.pageNumber || 1,
          pageSize: params.pageSize || 50,
          isCountRequired: true
        }
      );
      return response?.data || { pagedData: [], totalCount: 0 };
    } catch (error) {
      console.error("Error fetching route journey history:", error);
      return { pagedData: [], totalCount: 0 };
    }
  },

  /**
   * Get upcoming journey plans for next N days
   */
  async getUpcomingJourneyPlans(params: {
    orgUID: string;
    days: number;
    empUID?: string;
  }) {
    try {
      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + params.days);

      const response = await apiService.post(
        "/UserJourney/GetUpcomingJourneyPlans",
        {
          orgUID: params.orgUID,
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString(),
          empUID: params.empUID || ""
        }
      );
      return response?.data || [];
    } catch (error) {
      console.error("Error fetching upcoming journey plans:", error);
      return [];
    }
  },

  /**
   * Check if journey plan exists for a date
   * Used to verify auto-generation worked
   */
  async checkJourneyPlanExists(params: {
    routeUID: string;
    date: string;
  }): Promise<boolean> {
    try {
      const beatHistoryUID = `${params.routeUID}_${params.date.replace(
        /-/g,
        "_"
      )}`;
      const response = await apiService.get(
        `/UserJourney/CheckJourneyPlanExists?beatHistoryUID=${beatHistoryUID}`
      );
      return response?.data?.exists || false;
    } catch (error) {
      console.error("Error checking journey plan existence:", error);
      return false;
    }
  },

  /**
   * MOBILE APP FUNCTIONS - For Salesman Execution
   * These are read-only references - actual execution happens in mobile app
   */

  /**
   * Get today's journey plan for logged-in salesman
   */
  async getMyTodayJourneyPlan(empUID: string): Promise<JourneyPlan | null> {
    try {
      const today = new Date().toISOString().split("T")[0];
      const response = await apiService.post(
        "/UserJourney/GetMyTodayJourneyPlan",
        {
          empUID,
          visitDate: today
        }
      );
      return response?.data || null;
    } catch (error) {
      console.error("Error fetching my journey plan:", error);
      return null;
    }
  }

  /**
   * NOTE: The following actions are performed by mobile app only:
   * - Start Journey (POST /UserJourney/StartJourney)
   * - Store Check-In (POST /StoreHistory/CheckIn)
   * - Store Check-Out (POST /StoreHistory/CheckOut)
   * - End Journey (POST /UserJourney/EndJourney)
   * - Skip Store (POST /StoreHistory/SkipStore)
   *
   * This web service only VIEWS the results, never initiates these actions
   */
};

/**
 * IMPORTANT NOTES:
 *
 * 1. Journey Plans are AUTO-GENERATED by stored procedures:
 *    - generate_beat_history() - Creates beat_history records
 *    - generate_store_history() - Creates store_history records
 *    - Run nightly at 11 PM via scheduled job
 *
 * 2. Generation Logic:
 *    - Creates plans for next 15 days
 *    - Based on route schedules (daily/weekly/monthly)
 *    - Excludes holidays and weekends (if configured)
 *    - Assigns to primary salesman from route_users
 *
 * 3. Beat History UID Format:
 *    - {route_uid}_{YYYY}_{MM}_{DD}
 *    - Example: ROUTE-NORTH-01_2024_01_15
 *
 * 4. Web Admin Capabilities:
 *    - View journey plans (this service)
 *    - Reassign to different salesman
 *    - Cancel unstarted plans
 *    - View execution history
 *
 * 5. Mobile App Capabilities:
 *    - Execute journey plans
 *    - Check-in/out at stores
 *    - Record orders
 *    - Skip stores with reason
 *
 * 6. NO MANUAL CREATION:
 *    - Journey plans CANNOT be created manually
 *    - They are ONLY auto-generated from routes
 *    - To get journey plans, create/modify routes
 */
